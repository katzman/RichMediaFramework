/** ProgressEventManager * ------------------------------------------------------------------------------------- * @ description: Image gallery component, uses either external or internal images. * @ developer: Neil Katz * @ version: 1.0.0  04.20.2015 * ------------------------------------------------------------------------------------- * */package com.richMedia.components{	import com.greensock.TweenNano;	import com.greensock.easing.*;	import com.richMedia.components.DCAssetLoader;	import com.richMedia.events.RmAdEvent;	import com.richMedia.managers.LibResourceManager;	import com.richMedia.managers.doubleclick.DCTrackingManager;	import flash.display.Bitmap;	import flash.display.DisplayObject;	import flash.display.MovieClip;	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.KeyboardEvent;	import flash.events.MouseEvent;	import flash.geom.Point;	public class DCGalleryComponent extends EventDispatcher	{		// transistion constants		public static const TRANS_X_SLIDE       : String = 'xSlide';		public static const TRANS_Y_SLIDE       : String = 'ySlide';		public static const TRANS_ALPHA         : String = 'alpha';		public static const TRANS_SCALE         : String = 'scaleBoth';		public static const DIRECTION_NEXT      : String = 'next';		public static const DIRECTION_PREV      : String = 'prev';		public var useKeyboard                  : Boolean;		public var transitionType               : String =  TRANS_ALPHA;		public var transitionTime               : Number = .5;		public var easeType                     : Object = Quad.easeInOut;		public var loop                         : Boolean;		public var scaleToFit                   : Boolean;		public var closeOnClicked               : Boolean;		public var imageLoaded                  : Function;		public var showDisabledBtn              : Function;		public var showEnabledBtn               : Function;		public var currentImage                 : uint = 0;		private var galleryLoader               : DCAssetLoader;		private var target                      : MovieClip;		private var galleryItems                : Array = [];		private var currentBitmap               : Bitmap;		private var newBitmap                   : Bitmap;		private var nextBtn                     : MovieClip;		private var prevBtn                     : MovieClip;		private var direction                   : String;		private var galleryReady                : Boolean;		private var targetWidth                 : Number;		private var targetHeight                : Number;		public function DCGalleryComponent( _target:MovieClip, _nextBtn:MovieClip, _prevBtn:MovieClip, _loop:Boolean = false )		{			if( !_target )			{				throw new Error( "ALARM!!! :: FULLSCREEN COMPONENT :: CONSTRUCTOR :: NO VALID STAGE SET" );			}			target      = _target;			loop        = _loop;			nextBtn     = _nextBtn;			prevBtn     = _prevBtn;			trace( "***********************************************************" );			trace( "**************** GALLERY COMPONENT V 1.0.0 ****************" );			trace( "***********************************************************" );		}		public function init():void		{			target.addEventListener( Event.REMOVED_FROM_STAGE, destroy );			if( nextBtn ) nextBtn.addEventListener( MouseEvent.CLICK, mouseEvent );			if( prevBtn ) prevBtn.addEventListener( MouseEvent.CLICK, mouseEvent );			target.addEventListener( MouseEvent.CLICK, fireExit );			galleryLoader = new DCAssetLoader();			galleryLoader.addEventListener( RmAdEvent.ASSET_LOAD_COMPLETE, imageLoadComplete );			galleryLoader.addEventListener( RmAdEvent.ASSET_LOAD_ERROR, loadError )			if( !loop ) disableBtn( prevBtn );			loadImage();			if( !useKeyboard ) return;			if( target.stage ) setKeyboard();			else target.addEventListener( Event.ADDED_TO_STAGE, setKeyboard );		}		private function loadError( e:RmAdEvent ):void		{			trace( "GALLERY LOAD ERROR" );			galleryReady = true;		}		public function destroy( e : Event = null ):void		{			if( galleryLoader ) galleryLoader.destroy();			galleryLoader = null;			galleryItems = null;			target = null;		}		public function addGalleryItem( _path:String = "", _libId:String = "", _trackId:String = "", _exit:String = "" ):void		{			galleryItems.push({ path:_path, libID:_libId, trackID:_trackId, exit:_exit });		}		private function setKeyboard( e:Event = null ):void		{			target.removeEventListener( Event.ADDED_TO_STAGE, setKeyboard );			target.stage.addEventListener(KeyboardEvent.KEY_UP, keyUp );		}		private function keyUp( e:KeyboardEvent ):void		{			if( !galleryReady ) return;			switch( e.keyCode )			{				case 39:					if( transitionType != TRANS_Y_SLIDE ) nextImage();					break;				case 38:					if( transitionType == TRANS_Y_SLIDE ) nextImage();					break;				case 37:					if( transitionType != TRANS_Y_SLIDE ) prevImage();					break;				case 40:					if( transitionType == TRANS_Y_SLIDE ) prevImage();					break;			}		}		private function fireExit( event:MouseEvent ):void		{			var image:Object = galleryItems[currentImage];			if( image && image.exit != "" ) DCTrackingManager.fireExit( image.exit );			if( closeOnClicked ) DCTrackingManager.collapseUnit( true );			dispatchEvent( new RmAdEvent( RmAdEvent.CLICK_FIRED ));		}		public function mouseEvent( e:MouseEvent ):void		{			if( !galleryReady ) return;			if( e.currentTarget == nextBtn ) nextImage();			else prevImage();		}		public function nextImage( btn:DisplayObject = null ):void		{			if( currentImage < ( galleryItems.length -1 ))			{				enableBtn( prevBtn );				direction = DIRECTION_NEXT;				currentImage++;				loadImage();				if( currentImage == ( galleryItems.length -1 ) && !loop ) disableBtn( nextBtn );			}			else if( loop )			{				currentImage = 0;				direction = DIRECTION_NEXT;				loadImage();			}		}		public function prevImage( btn:DisplayObject = null ):void		{			if( currentImage > 0)			{				enableBtn( nextBtn );				direction = DIRECTION_PREV;				currentImage--;				loadImage();				if( currentImage == 0 && !loop ) disableBtn( prevBtn );			}			else if( loop )			{				currentImage = galleryItems.length -1;				direction = DIRECTION_PREV;				loadImage();			}		}		public function loadImage():void		{			galleryReady = false;			var image:Object = galleryItems[currentImage];			if( !image ) return;			if( image.path != "" )			{				galleryLoader.loadBitmap( image.path );			}			else if( image.libID != "" )			{				newBitmap = LibResourceManager.getBitmap( image.libID );				if( imageLoaded != null ) imageLoaded( newBitmap );				showImage();			}			if( image.trackID != "" ) DCTrackingManager.trackCounter( image.trackID );		}		private function imageLoadComplete( e:RmAdEvent ) : void		{			newBitmap = e.data as Bitmap;			newBitmap.smoothing = true;			if( imageLoaded != null ) imageLoaded( newBitmap );			showImage();		}		/*		private function scaleImages():void		{			if( !scaleToFit ) return;			var scale:Number;			var scaleWidth:Number =  stageWidth / targetWidth;			var scaleHeight:Number =  stageHeight / targetHeight;			scale = ( scaleWidth < scaleHeight ) ? scaleWidth : scaleHeight;		}		*/		private function showImage():void		{			switch( transitionType )			{				case TRANS_ALPHA:					transitionAlpha();					break;				case TRANS_X_SLIDE:					transitionXSlide();					break;				case TRANS_Y_SLIDE:					transitionYSlide();					break;				case TRANS_SCALE:					transitionScale()			}		}		private function transitionScale():void		{			newBitmap.x = newBitmap.width * .5;			newBitmap.y = newBitmap.height * .5;			newBitmap.scaleX = 0;			newBitmap.scaleY = 0;			target.addChild( newBitmap );			TweenNano.to( newBitmap, transitionTime, { scaleX:1, scaleY:1, x:0, y:0, onComplete:clearPrevImage, ease:easeType });		}		private function transitionAlpha():void		{			newBitmap.alpha = 0;			target.addChild( newBitmap );			TweenNano.to( newBitmap, .5, { alpha:1, onComplete:clearPrevImage });		}		private function transitionXSlide():void		{			var currentXpos:Number;			target.addChild( newBitmap );			if( currentBitmap )			{				newBitmap.x = getPosition( newBitmap ).x;				currentXpos = -getPosition( currentBitmap ).x;				TweenNano.to( currentBitmap, transitionTime, { x:currentXpos, ease:easeType });			}			else			{				newBitmap.x = -getPosition( newBitmap ).x;			}			TweenNano.to( newBitmap, transitionTime, { x:0, onComplete:clearPrevImage, ease:easeType });		}		private function transitionYSlide():void		{			var currentYpos:Number;			target.addChild( newBitmap );			if( currentBitmap )			{				newBitmap.y = -getPosition( newBitmap ).y;				currentYpos = getPosition( currentBitmap ).y;				TweenNano.to( currentBitmap, transitionTime, { y:currentYpos, ease:easeType });			}			else			{				newBitmap.y = getPosition( newBitmap ).y;			}			TweenNano.to( newBitmap, transitionTime, { y:0, onComplete:clearPrevImage, ease:easeType });		}		private function getPosition( image:Bitmap ):Point		{			if( !image ) return null;			var xpos:Number = ( direction == DIRECTION_NEXT ) ? image.width : -image.width;			var ypos:Number = ( direction == DIRECTION_NEXT ) ? image.height : -image.height;			var point:Point = new Point( xpos, ypos );			return point;		}		private function clearPrevImage():void		{			if( target && currentBitmap && target.contains( currentBitmap ))			{				target.removeChild( currentBitmap );			}			currentBitmap = newBitmap;			newBitmap = null;			galleryReady = true;		}		private function disableBtn( btn:MovieClip ):void		{			if( !btn ) return;			if( showDisabledBtn != null )			{				showDisabledBtn( btn );			}			else if( btn['disable'] )			{				btn['disable']();			}			else			{				btn.mouseEnabled = false;				TweenNano.to( btn, .5, {alpha:.3});			}		}		private function enableBtn( btn:MovieClip ):void		{			if( !btn ) return;			if( showEnabledBtn != null )			{				showEnabledBtn( btn );			}			else if( btn['enable'] )			{				btn['enable']();			}			else			{				btn.mouseEnabled = true;				TweenNano.to( btn, .5, {alpha:1});			}		}	}}