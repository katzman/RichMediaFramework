/** MMVideoPlayer * ------------------------------------------------------------------------------------- * @ description: wrapper for the media mind video player * @ usage: refer to documentation for usage. * @ developer: Neil Katz * @ version: 1.0.0  02.13.2014 * ------------------------------------------------------------------------------------- * */package com.richMedia.video.mediamind{	import com.richMedia.managers.ProgressEventManager;	import com.richMedia.components.TuneIn;	import com.richMedia.managers.VideoListManager;	import com.richMedia.constants.Constants;	import com.richMedia.events.RmAdEvent;	import com.richMedia.events.EventBroadcaster;	import com.richMedia.events.RmVideoEvent;	import com.richMedia.utils.Utils;	import com.richMedia.video.vo.VideoVO;	import eyeblaster.events.EBErrorEvent;	import eyeblaster.events.EBMetadataEvent;	import eyeblaster.events.EBVideoEvent;	import eyeblaster.videoPlayer.VideoScreen;	import flash.display.MovieClip;	import flash.events.AsyncErrorEvent;	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.net.NetStream;	[Event(name="videoReady"			,type="com.richMedia.events.RmVideoEvent")]	[Event(name="videoError"			,type="com.richMedia.events.RmVideoEvent")]	[Event(name="videoCleared"			,type="com.richMedia.events.RmVideoEvent")]	[Event(name="videoStarted"			,type="com.richMedia.events.RmVideoEvent")]	[Event(name="videoComplete"			,type="com.richMedia.events.RmVideoEvent")]	[Event(name="videoLoopComplete"		,type="com.richMedia.events.RmVideoEvent")]	[Event(name="videoProgress"			,type="com.richMedia.events.RmVideoEvent")]	[Event(name="videoPlaying"			,type="com.richMedia.events.RmVideoEvent")]	[Event(name="videoPaused"			,type="com.richMedia.events.RmVideoEvent")]	[Event(name="videoStopped"			,type="com.richMedia.events.RmVideoEvent")]	[Event(name="videoUnmuted"			,type="com.richMedia.events.RmVideoEvent")]	[Event(name="videoMuted"			,type="com.richMedia.events.RmVideoEvent")]	[Event(name="video_0_percent"		,type="com.richMedia.events.RmVideoEvent")]	[Event(name="video_25_percent"		,type="com.richMedia.events.RmVideoEvent")]	[Event(name="video_50_percent"		,type="com.richMedia.events.RmVideoEvent")]	[Event(name="video_75_percent"		,type="com.richMedia.events.RmVideoEvent")]	[Event(name="video_100_percent"		,type="com.richMedia.events.RmVideoEvent")]	[Event(name="showBuffering"			,type="com.richMedia.events.RmVideoEvent")]	[Event(name="hideBuffering"			,type="com.richMedia.events.RmVideoEvent")]	[Event(name="playWithSoundCalled"	,type="com.richMedia.events.RmVideoEvent")]	[Event(name="videoOnCuepoint"		,type="com.richMedia.events.RmVideoEvent")]	[Event(name="videoBytesLoaded"		,type="com.richMedia.events.RmVideoEvent")]	[Event(name="videoUpdated"		    ,type="com.richMedia.events.RmVideoEvent")]	public class MMVideoPlayer extends EventDispatcher	{		////////////////////////////////////////////// PUBLIC VARS //////////////////////////////////////////////////////////////////////////////////		public var bufferTime		    : Number = 1;		public var closeOnComplete	    : Boolean = false;		public var reportDuration	    : Boolean = false;		public var startMuted		    : Boolean = false;		public var ignoreControls       : Boolean = false;		public var streamVideo		    : Boolean = false;		public var initVideoPlayed      : Boolean = false;		public var addSkipMenuItem      : Boolean = false;		public var pauseAtStart		    : Boolean = false;		public var pauseOnLastFrame     : Boolean = true;		public var videoSmoothing	    : Boolean = true;		public var loopVideoNum         : int = -1;		public var replayVideoNum       : int;		public var loopCount            : int = 1;		public var streamPath		    : String = "";		public var playerID             : String = Constants.PLAYER_DEFAULT_ID;		public var swfID                : String = Constants.SWF_DEFAULT_ID;		public var debug				: Boolean;		public var useLocalPath			: Boolean = true; // if videos are not in the swf folder then set to false.		public var isPaused             : Boolean;		public var isMuted              : Boolean;		////////////////////////////////////////////// PRIVATE VARS //////////////////////////////////////////////////////////////////////////////////		private var videoPlaying		: Boolean = false;  ////// variable to know if the video is playing		private var initialLoad			: Boolean = false;	////// variable used for first video play		private var videoDuration		: Number;		private var videoProgressEvent  : String;		private var videoNum			: int = 0;		private var videoId 	        : Number;		private var videoPath           : String;		private var videoReportingID    : String;		private var _tuneInID           : String = Constants.TUNEIN_DEFAULT_ID;		private var _videoListManager   : VideoListManager;		private var progressEventManager: ProgressEventManager;		private var broadcaster         : EventBroadcaster;		private var stream			    : NetStream;		private var videoScreen         : VideoScreen;		private var videoWidth			: Number;		private var videoHeight			: Number;		private var videoTarget         : MovieClip;		private var menuTarget          : MovieClip;		private var progressEvents_obj 	: Object;		private var useTuneIn           : Boolean;		private var playTestVideo		: Boolean;		private var isLoadAndPlay		: Boolean;		////////////////////////////////////////////// PUBLIC METHODS :: CONSTRUCTOR AND DESTROY METHODS //////////////////////////////////////////////////////////////////////////////////		/**		 * @name MMVideoPlayer Constructor		 * @param: _videoTarget: is the target movieclip that is on the stage, used for position and size of player.		 * @param: _startMuted: starts video with no sound, true by default.		 * @param: _useTunein: use tunein component data to retrieve date coded video.		 * @param: _streaming: just tells it to use streaming or not.		 * @param: _streamingPath: is used if you have a separate path to be added for streaming, can also be added to the video path when they are added.		 */		public function MMVideoPlayer( _videoTarget:MovieClip, _startMuted:Boolean = true, _useTunein:Boolean = false, _streaming:Boolean = false, _streamingPath:String = "" )		{			trace("***************************************************");			trace("******** MEDIA MIND VIDEO WRAPPER V 2.0.0 *********");			trace("***************************************************");			if( !_videoTarget )			{				throw new Error( "ALARM!!! :: must have a valid DoubleClick VideoPlayer object passed through the constructor" );				return;			}			videoTarget = _videoTarget;			streamVideo = _streaming;			streamPath  = _streamingPath;			useTuneIn   = _useTunein;			startMuted  = _startMuted;			videoWidth 	= videoTarget.width;			videoHeight = videoTarget.height;			// sets default id for videos.			if( !useTuneIn ) tuneInID = _tuneInID;		}		private function get videoListManager():VideoListManager		{			if( !_videoListManager ) _videoListManager = new VideoListManager( useTuneIn, swfID );			return _videoListManager;		}		public function init( e:Event = null ):void		{			setListeners();			sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_READY, {videoID:videoReportingID, playerID:playerID} ));		}		public function destroy( e:Event = null ):void		{			stopVideo();			clearVideoPlayer();			removeListeners();		}		/**		 * getter and setter for video path values		 * @description: if use local path true,		 * then it will get the path to the folder of the current running swf		 * and return it minus the swf element.		 *		 * This is used for local video testing, uses id's when swf is on MM.		 */		public function get filePath():String		{			if( !useLocalPath || streamVideo || videoPath.indexOf( "http" ) != -1 || videoPath.indexOf( "rtmp" ) != -1 ) return "";			var fullPath:String = videoTarget.loaderInfo.url;			var pathArray:Array = fullPath.split("/"); pathArray.pop();			var tempPath = pathArray.join("/") + "/";			return tempPath;		}		public function set tuneInID( value:String ):void		{			videoListManager.tuneInId = value;		}        /**         * videos are added in the flash IDE         * this method creates a generic object which adds         * videos based on their date code in an array.         */        public function addVideo( id:Number, pathHigh:String, reportingID:String = "video", day:String = "default" ):void        {            if( !pathHigh )            {                throw new Error( "ALARM!!! :: No valid path in add video. Double Click Player requires a path to load video" );                return;            }            videoListManager.addVideo( day, pathHigh, "", "", reportingID, id );        }        /**         * videos are added in the flash IDE         * this method creates a generic object which adds         * videos based on their date code in an array.         */        public function addVideos( id:Number, pathHigh:String, pathMid:String = "", pathLow:String = "", reportingID:String = "video", day:String = "default" ):void        {            if( !pathLow && !pathMid && !pathHigh )            {                throw new Error( "ALARM!!! :: No valid path in add video. Double Click Player requires a path to load video" );                return;            }            videoListManager.addVideo( day, pathHigh, pathMid, pathLow, reportingID, id );        }        /**		 * add a percent value between 0 and 1 or a an actual time value, fires a method when video reaches that point of the video.		 */		public function addProgressEvent( time:String, videoID:String, method:Function = null, useTime:Boolean = false ):void		{			if( !progressEventManager ) progressEventManager = new ProgressEventManager();			progressEventManager.addProgressEvent( time, videoID, method, useTime );		}        public function resetProgressEvents():void        {            if( !progressEventManager ) return;            progressEventManager.resetEvents();        }		////////////////////////////////////////////// PUBLIC METHODS :: LOAD AND PLAY VIDEO //////////////////////////////////////////////////////////////////////////////////		/**		 * Loads and plays the first video on the list, sets initload value to false.		 */		public function playInitVideo( e:RmAdEvent = null ):void		{			broadcaster.removeEventListener( RmAdEvent.TUNEIN_READY, playInitVideo );			if( useTuneIn && !TuneIn.isReady )			{				broadcaster.addEventListener( RmAdEvent.TUNEIN_READY, playInitVideo );				return;			}			loadNewVideo( 0, false );		}		/**		 * Loads and plays video by video array position		 */		public function loadNewVideo( vid:int, initLoad:Boolean = true ):void		{			initVideoPlayed = initLoad;			setVideoProps( vid );			setUpVideo();		}		/**		 * Loads and plays video by video path and reporting id, doesn't need to have video list.		 */		public function loadAndPlay( path:String, id:Number, reportingID:String = "default" ):void		{			isLoadAndPlay = true;			setVideoProps( -1, path, id, reportingID );			pauseAtStart = false;			setUpVideo();		}		/**		 * Loads and plays video by video path and reporting id, doesn't need to have video list.		 */		public function loadAndPause( path:String, id:Number, reportingID:String = "default" ):void		{			setVideoProps( -1, path, id, reportingID );			pauseAtStart = true;			setUpVideo();		}		////////////////////////////////////////////// PUBLIC METHODS :: REPLAY VIDEO //////////////////////////////////////////////////////////////////////////////////		public function replayVideo( num:int = -1 ):void		{			trace( "\n\n\nREPLAY VIDEO CALLED :: LOOP COUNT: " + loopCount + "   LOOP NUM: " + loopVideoNum + "   NUM: " + num + "\n\n\n");			if( videoNum == num || num == -1 || isLoadAndPlay )			{				seekVideo( null, 0 );				videoScreen.play();			}			else			{				replayWithSound( num );			}			sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_PLAYING, { videoID:videoReportingID, playerID:playerID } ));		}		public function replayWithSound( num:int = -1 ):void		{			var vidNum:uint;			if( isLoadAndPlay )			{				replayVideo();			}			else			{				if( num != -1 ) vidNum = num;				else if( replayVideoNum != -1 ) vidNum = replayVideoNum;				else if( videoNum ) vidNum = videoNum;				loadNewVideo( vidNum );			}			sendVideoEvent( new RmVideoEvent( RmVideoEvent.PLAY_WITH_SOUND_CALLED, {videoID:videoReportingID, playerID:playerID}));			clearInitValues();			unmuteAudio();		}		////////////////////////////////////////////// PUBLIC METHODS :: VIDEO CONTROLS COMMANDS //////////////////////////////////////////////////////////////////////////////////		public function playVideo( e:RmVideoEvent = null ):void		{			if( e && e.data.playerID != playerID ) return;			if( !videoScreen )			{				trace("ALARM!!! ::: PLAY VIDEO CALLED : NO VIDEO SCREEN" );				return;			}			videoScreen.play();			isPaused = false;			sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_PLAYING, {videoID:videoReportingID, playerID:playerID} ));		}		public function setVideoVolume( _vol:Number ):void		{			videoScreen.volume = _vol;		}		public function muteAudio( e:RmVideoEvent = null ):void		{			if( e && e.data.playerID != playerID ) return;			setVideoVolume( 0 );			isMuted = true;			sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_MUTED, {videoID:videoReportingID, playerID:playerID} ));		}		public function unmuteAudio( e:RmVideoEvent = null ):void		{			if( e && e.data.playerID != playerID ) return;			setVideoVolume( 100 );			isMuted = false;			checkForReplay();			sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_UNMUTED, {videoID:videoReportingID, playerID:playerID} ));		}		public function pauseVideo( e:RmVideoEvent = null ):void		{			if( e && e.data.playerID != playerID ) return;			if( !videoScreen )			{				trace("ALARM!!! ::: PAUSE VIDEO CALLED : NO VIDEO VIDEO SCREEN" );				return;			}			if( isPaused ) return;			isPaused = true;			videoScreen.pause();			sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_PAUSED, {videoID:videoReportingID, playerID:playerID} ));		}		public function stopVideo( e:RmVideoEvent = null ):void		{			if( !videoScreen )			{				trace("ALARM!!! ::: STOP VIDEO CALLED : NO VIDEO SCREEN" );				return;			}			videoScreen.stop();			sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_STOPPED, {videoID:videoReportingID, playerID:playerID} ));		}		public function seekVideo( e:RmVideoEvent, _seek:Number = 0 ):void		{			if( e && e.data.playerID != playerID ) return;			if( !videoScreen )			{				trace("ALARM!!! ::: SEEK VIDEO CALLED : NO VIDEO SCREEN" );				return;			}			if ( e ) _seek = e.data.seekPos;			var _seekPos:Number = videoDuration * _seek;			videoScreen.seek( _seekPos );		}		/**		 * Sets video back to the start and pauses it.		 */		public function resetVideo():void		{			seekVideo( null, 0 );			pauseVideo();		}		/**		 * Skips video to end, can be called from right click menu once i figure it out.		 */		public function skipVideo( _skip:Number = .9 ):void		{			seekVideo( null, _skip );		}		////////////////////////////////////////////// PRIVATE METHODS //////////////////////////////////////////////////////////////////////////////////		/**		 * sets the video path, video id, and reporting id.		 */		private function setVideoProps( _pos:int, _path:String = "", _videoId:Number = 0, _reportingID:String = "" ):void		{			if( _pos == -1 && _path == "" )			{				trace("ALARM!!! ::: NO VALID VIDEO PATH OR ARRAY POSITION" );				return;			}			var videoObj:VideoVO;			if( _pos != -1 )			{				if( !videoListManager.getCurrentVideo( _pos ) )				{					throw new Error("ALARM!!! ::: SET VIDEO PROPERTIES CALLED : VIDEO ARRAY IS NULL -- Make sure videos have been added before playing video." );					return;				}				videoNum 			= _pos;				videoObj 			= videoListManager.getCurrentVideo( videoNum );				videoPath 			= videoObj.videoPath;				videoId 			= videoObj.videoID;				videoReportingID 	= videoObj.videoReportingID;			}			else			{				videoPath 			= _path;				videoReportingID 	= _reportingID;				videoId 			= _videoId;			}			setReportingID();		}		/**		 * Calls the set up video methods in order.		 */		private function setUpVideo():void		{			stopVideo();			clearVideoPlayer();			showBuffering();			initVideoPlayer();		}		/**		 * Decides which video loader to use based on video path and paused at start.		 */		private function loadVideo():void		{			var extVideo:Boolean = ( Utils.getPlayerType() != Utils.PLAYER_PLUGIN );			if( pauseAtStart )			{				if( extVideo ) mmLoadPath();				else mmLoad();			}			else			{				if( extVideo ) mmLoadAndPlayPath();				else mmLoadAndPlay();			}		}		private function mmLoadAndPlay():void		{			videoScreen.loadAndPlay( videoId );			sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_PLAYING, {videoID:videoReportingID, playerID:playerID} ));		}		private function mmLoad():void		{			videoScreen.load( videoId );		}		private function mmLoadAndPlayPath():void		{			trace( "\n\nMM LOAD AND PLAY PATH: " + streamPath + filePath + videoPath + "\n\n" );			videoScreen.loadAndPlayExt( streamPath + filePath + videoPath );			sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_PLAYING, {videoID:videoReportingID, playerID:playerID} ));		}		private function mmLoadPath():void		{			videoScreen.loadExt( streamPath + filePath + videoPath );		}		/**		 * removes and destroys current videoPlayer object.		 */		public function clearVideoPlayer( e:Event = null ):void		{			trace( "\n\n\nCLEAR VIDEO PLAYER CALLED\n\n\n" );			if( videoScreen ) videoScreen.stopAndClear();			if( videoTarget && videoScreen && videoTarget.contains( videoScreen )) videoTarget.removeChild ( videoScreen );			videoScreen         = null;			videoProgressEvent  = null;			progressEvents_obj  = null;			isPaused            = false;			sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_CLEARED, {videoID:videoReportingID, playerID:playerID} ));		}		/**		 * Inits player, properties are set in the flash IDE, fired everytime a new video is loaded.		 */		private function initVideoPlayer():void		{			videoScreen = new VideoScreen();			videoScreen.addEventListener( Event.INIT, 							setComponentProperties );			videoScreen.addEventListener( EBMetadataEvent.METADATA_RECEIVED, 	onMetaData );			videoScreen.addEventListener( EBMetadataEvent.CUE_POINT, 			onCuePoint );			videoScreen.addEventListener( EBVideoEvent.PLAY_PROGRESS, 			updateProgress );			videoScreen.addEventListener( EBVideoEvent.MOVIE_START, 			statusChanged );			videoScreen.addEventListener( EBVideoEvent.PLAYBACK_START, 			statusChanged );			videoScreen.addEventListener( EBVideoEvent.PLAYBACK_STOP, 			statusChanged );			videoScreen.addEventListener( EBVideoEvent.STATUS_CHANGED, 			statusChanged );			videoScreen.addEventListener( EBErrorEvent.ERROR, 					errorHandler );			videoScreen.addEventListener( EBVideoEvent.LOAD_PROGRESS, 			updateLoad );			videoScreen.addEventListener( EBVideoEvent.MOVIE_END, 				videoComplete );			videoTarget.addChild( videoScreen );		}		private function setComponentProperties( e:Event = null ):void		{			videoScreen.setSize( videoWidth, videoHeight );			videoScreen.name = videoReportingID;			videoScreen.isStreaming = streamVideo;			videoScreen.smoothing = true;			videoScreen.muteOnVideoStart = startMuted;			//videoScreen.pauseOnLastFrame = pauseOnLastFrame;			loadVideo();		}		private function errorHandler( event:EBErrorEvent ):void		{			trace("ErrorEvent: " + event );			////trace_r( event );		}		private function asyncHandler( event:AsyncErrorEvent ):void		{			trace("AsyncErrorEvent: " + event );			////trace_r( event );		}		/**		 * Loops video based on the loopVideoNum value.		 */		private function loopVideo():void		{			trace("CHECKING LOOP ::: LOOPCOUNT: " + loopCount + " < " + loopVideoNum );			if( loopCount < loopVideoNum )			{				replayVideo();				loopCount++;			}			else			{				loopCount = 0;				loopVideoNum = -1;				sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_LOOP_COMPLETE, {videoID:videoReportingID, playerID:playerID} ));			}		}		/**		 * When unmute is called, it will check if it was started muted and the first video, and replay with sound.		 */		private function checkForReplay():void		{			if( !initVideoPlayed && startMuted )			{				replayWithSound();				clearInitValues();			}		}		private function videoError ( e:Event ):void		{			trace ( "\n\n\nVIDEO ERROR: " );			onPlayerError();		}		/**		 * set properties once the video loads and gets meta data.		 */		private function onMetaData( e:EBMetadataEvent ):void		{			trace( "\n\n\nON META DATA CALLED" );			videoDuration = e.info.duration;			videoPlaying = true;			stream = videoScreen.netStream;			sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_STARTED, {videoID:videoReportingID, playerID:playerID} ));			hideBuffering();			isVideoMuted();		}		private function onCuePoint( e:EBMetadataEvent ):void		{			sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_ON_CUEPOINT, {videoID:videoReportingID, playerID:playerID, pointObj:e.info} ));		}		/**		 * Mutes video if startMuted is set and initVideoPlayed is false.		 */		private function isVideoMuted():void		{			if( !initVideoPlayed && startMuted ) muteAudio();			else unmuteAudio();		}		////////////////////////////////////////////// VIDEO EVENTS //////////////////////////////////////////////////////////////////////////////////		private function setReportingID():void		{			sendVideoEvent( new RmVideoEvent( RmVideoEvent.UPDATE_VIDEO_ID, {videoID:videoReportingID, playerID:playerID}));		}		private function hideBuffering():void		{			sendVideoEvent( new RmVideoEvent( RmVideoEvent.HIDE_BUFFERING, {videoID:videoReportingID, playerID:playerID} ));		}		private function showBuffering():void		{			sendVideoEvent( new RmVideoEvent( RmVideoEvent.SHOW_BUFFERING, {videoID:videoReportingID, playerID:playerID} ));		}		private function videoComplete( e:EBVideoEvent = null ):void		{			clearInitValues();			handleVideoCompleteProps();			sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_COMPLETE, {videoID:videoReportingID, playerID:playerID} ));		}		private function onPlayerError():void		{			sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_ERROR, {videoID:videoReportingID, playerID:playerID} ));		}		/**		 * Updates progress bar load bar, only works on progressive loads.		 */		private function updateLoad( e:EBVideoEvent ):void		{			var bytesLoaded:Number = e.loadProgress / 100 || 0;			sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_BYTES_LOADED, { bytesLoaded:bytesLoaded, videoID:videoReportingID, playerID:playerID }));		}		/**		 * Updates video progress bar.		 */		private function updateProgress( e:EBVideoEvent ):void		{			var pos:Number = e.playProgress / 100 || 0;			sendProgressEvent( pos );			checkForProgressCallback( pos );			sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_PROGRESS, { videoID:videoReportingID, playerID:playerID, progress:pos }));		}		private function checkForProgressCallback( _pos:Number ):void		{			if( !progressEventManager || !progressEventManager.getProgressList( videoReportingID )) return;			var eventList:Array = progressEventManager.getProgressList( videoReportingID );			var obj:Object;			var pos:Number;			var length:uint = eventList.length;			for( var i:uint = 0; i < length; i++ )			{				obj = eventList[i];				pos = ( obj.useTime ) ? ( videoScreen.time || 0 ) : _pos;				if( pos >= obj.time && !obj.fired )				{					obj.fired = true;					obj.callback( obj.value );				}			}		}		private function sendProgressEvent( _pos:Number ):void		{			var event:RmVideoEvent;			var eventType:String;			if( _pos < .25 )         eventType = RmVideoEvent.VIDEO_0_PERCENT;			else if( _pos < .5 )     eventType = RmVideoEvent.VIDEO_25_PERCENT;			else if( _pos < .75 )    eventType = RmVideoEvent.VIDEO_50_PERCENT;			else if( _pos < .97 )    eventType = RmVideoEvent.VIDEO_75_PERCENT;			else                     eventType = RmVideoEvent.VIDEO_100_PERCENT;			if( eventType != videoProgressEvent )			{				event = new RmVideoEvent( eventType, {videoID:videoReportingID, playerID:playerID} );				sendVideoEvent( event );				videoProgressEvent = eventType;			}		}		/**		 * Fires all outgoing events on both the player and the event broadcaster.		 */		private function sendVideoEvent( event:RmVideoEvent )		{			dispatchEvent( event );			dispatchEvent( new RmVideoEvent( RmVideoEvent.VIDEO_UPDATED, { event:event.type, videoID:videoReportingID, playerID:playerID } ));			var event2:RmVideoEvent;			if( !ignoreControls )			{				event2 = new RmVideoEvent( event.type, event.data );				broadcaster.dispatchEvent( event2 );			}		}		////////////////////////////////////////////// PRIVATE METHODS //////////////////////////////////////////////////////////////////////////////////		private function statusChanged( e:EBVideoEvent ):void		{			trace( "VIDEO STATUS CHANGED :: " + e.type );		}		/**		 * Clears all initial player values once first video is complete or user input.		 */		private function clearInitValues():void		{			initVideoPlayed = true;			isPaused = false;		}		/**		 * On video complete checks for looping or close.		 */		private function handleVideoCompleteProps():void		{			if( closeOnComplete )    destroy();			if( loopVideoNum != -1 ) loopVideo();		}		private function setListeners():void		{			broadcaster = EventBroadcaster.getInstance();			videoTarget.addEventListener( Event.REMOVED_FROM_STAGE, destroy );			if( ignoreControls ) return;			broadcaster.addEventListener( RmVideoEvent.MUTE_VIDEO, muteAudio );			broadcaster.addEventListener( RmVideoEvent.UNMUTE_VIDEO, unmuteAudio );			broadcaster.addEventListener( RmVideoEvent.PAUSE_VIDEO, pauseVideo );			broadcaster.addEventListener( RmVideoEvent.PLAY_VIDEO, playVideo );			broadcaster.addEventListener( RmVideoEvent.STOP_VIDEO, stopVideo );			broadcaster.addEventListener( RmVideoEvent.SEEK_VIDEO, seekVideo );		}		private function removeListeners():void		{			videoTarget.removeEventListener( Event.REMOVED_FROM_STAGE, destroy );			broadcaster.removeEventListener( RmVideoEvent.MUTE_VIDEO, muteAudio );			broadcaster.removeEventListener( RmVideoEvent.UNMUTE_VIDEO, unmuteAudio );			broadcaster.removeEventListener( RmVideoEvent.PAUSE_VIDEO, pauseVideo );			broadcaster.removeEventListener( RmVideoEvent.PLAY_VIDEO, playVideo );			broadcaster.removeEventListener( RmVideoEvent.STOP_VIDEO, stopVideo );			broadcaster.removeEventListener( RmVideoEvent.SEEK_VIDEO, seekVideo );		}	}}