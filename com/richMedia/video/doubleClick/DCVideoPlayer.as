/** DCVideoPlayer * ------------------------------------------------------------------------------------- * @ description: wrapper for the doubleclick video player. * @ usage: refer to documentation for usage. * @ developer: Neil Katz * @ version: 1.0.0  02.13.2014 * ------------------------------------------------------------------------------------- * */package com.richMedia.video.doubleClick{	import com.richMedia.managers.NotificationManager;	import com.richMedia.managers.ProgressEventManager;	import com.richMedia.dateUtils.TuneIn;	import com.richMedia.managers.VideoListManager;	import com.richMedia.constants.Constants;	import com.richMedia.events.RmAdEvent;	import com.richMedia.events.EventBroadcaster;	import com.richMedia.events.RmVideoEvent;	import com.richMedia.video.vo.VideoVO;	import com.richMedia.managers.doubleclick.DCTrackingManager;    // google imports	import com.google.ads.studio.ProxyEnabler;	import com.google.ads.studio.events.StudioVideoEvent;	import com.google.ads.studio.video.SmartStreamingConnection;	import com.google.ads.studio.video.VideoController;	import com.google.ads.studio.video.VideoEntry;	import com.google.ads.studio.video.VideoPlayer;	import flash.display.MovieClip;	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.media.Video;	import flash.net.NetStream;	[Event(name="videoReady"			,type="com.richMedia.events.RmVideoEvent")]	[Event(name="videoError"			,type="com.richMedia.events.RmVideoEvent")]	[Event(name="videoCleared"			,type="com.richMedia.events.RmVideoEvent")]	[Event(name="videoStarted"			,type="com.richMedia.events.RmVideoEvent")]	[Event(name="videoComplete"			,type="com.richMedia.events.RmVideoEvent")]	[Event(name="videoLoopComplete"		,type="com.richMedia.events.RmVideoEvent")]	[Event(name="videoStopped"			,type="com.richMedia.events.RmVideoEvent")]	[Event(name="videoProgress"			,type="com.richMedia.events.RmVideoEvent")]	[Event(name="videoPlaying"			,type="com.richMedia.events.RmVideoEvent")]	[Event(name="videoPaused"			,type="com.richMedia.events.RmVideoEvent")]	[Event(name="videoUnmuted"			,type="com.richMedia.events.RmVideoEvent")]	[Event(name="videoMuted"			,type="com.richMedia.events.RmVideoEvent")]	[Event(name="video_0_percent"		,type="com.richMedia.events.RmVideoEvent")]	[Event(name="video_25_percent"		,type="com.richMedia.events.RmVideoEvent")]	[Event(name="video_50_percent"		,type="com.richMedia.events.RmVideoEvent")]	[Event(name="video_75_percent"		,type="com.richMedia.events.RmVideoEvent")]	[Event(name="video_100_percent"		,type="com.richMedia.events.RmVideoEvent")]	[Event(name="showBuffering"			,type="com.richMedia.events.RmVideoEvent")]	[Event(name="hideBuffering"			,type="com.richMedia.events.RmVideoEvent")]	[Event(name="playWithSoundCalled"	,type="com.richMedia.events.RmVideoEvent")]	[Event(name="videoOnCuepoint"		,type="com.richMedia.events.RmVideoEvent")]	[Event(name="videoBytesLoaded"		,type="com.richMedia.events.RmVideoEvent")]	[Event(name="videoUpdated"		    ,type="com.richMedia.events.RmVideoEvent")]	public class DCVideoPlayer extends EventDispatcher	{		////////////////////////////////////////////// PUBLIC VARS //////////////////////////////////////////////////////////////////////////////////		public var bufferTime		    : Number = 1;		public var closeOnComplete	    : Boolean = false;		public var reportDuration	    : Boolean = false;		public var startMuted		    : Boolean = false;		public var pauseAtStart		    : Boolean = false;		public var ignoreControls       : Boolean = false;		public var streamVideo		    : Boolean = false;		public var initVideoPlayed      : Boolean = false;		public var isPlaying			: Boolean = false;		public var videoSmoothing	    : Boolean = true;		public var loopVideoNum         : int = -1;		public var replayVideoNum       : int = -1;		public var loopCount            : int = 0;		public var streamPath		    : String = "";		public var playerID             : String = Constants.PLAYER_DEFAULT_ID;		public var swfID                : String = Constants.SWF_DEFAULT_ID;		public var enabler              : ProxyEnabler = ProxyEnabler.getInstance();		public var videoController		: VideoController;		public var isPaused            	: Boolean = true;		public var isMuted             	: Boolean;        public var userMuted            : Boolean;        public var userUnmuted          : Boolean;		public var isEngaged            : Boolean;		////////////////////////////////////////////// PRIVATE VARS //////////////////////////////////////////////////////////////////////////////////		private var videoPlaying		: Boolean = false;  ////// variable to know if the video is playing		private var videoDuration		: Number;		private var videoProgressEvent  : String;		private var videoNum			: int = 0;		private var videoPath           : String;		private var videoReportingID    : String = "default";		private var _tuneInID           : String = Constants.TUNEIN_DEFAULT_ID;		private var videoTimerID        : String;		private var currentVideoVO      : VideoVO;		private var preVideoVO          : VideoVO;		private var postVideoVO         : VideoVO;		private var videoToPlay         : int;        private var videoEntry			: VideoEntry;		private var _videoListManager   : VideoListManager;		private var progressEventManager: ProgressEventManager;		private var broadcaster         : EventBroadcaster;		private var progressEvents_obj 	: Object;		private var stream			    : NetStream;		private var videoPlayer			: VideoPlayer;		private var video			    : Video;		private var videoTarget         : MovieClip;		private var isLoadAndPlay		: Boolean;		private var useTuneIn           : Boolean;		/**		 * DCVideoPlayer Constructor		 * @param: _videoTarget: is the movieclip that is on the stage that the video player will be attached to and get it's width / height from.		 * @param: _startMuted: starts video with no sound.		 * @param: _useTunein: use tunein component data to retrieve date coded video.		 * @param: _streaming: just tells it to use streaming or not.		 * @param: _streamingPath: is used if you have a separate path to be added for streaming, can also be added to the video path when they are added.		 */		public function DCVideoPlayer( _videoTarget:MovieClip, _startMuted:Boolean = true, _useTunein:Boolean = false, _streaming:Boolean = false, _streamingPath:String = "" )		{			trace("***************************************************");			trace("******** DOUBLE CLICK VIDEO WRAPPER V 3.0.0 *******");			trace("***************************************************");			if( !_videoTarget )			{				throw new Error( "ALARM!!! :: must have a valid MovieClip object passed through the constructor" );				return;			}			videoTarget 	= _videoTarget;			streamVideo 	= _streaming;			streamPath  	= _streamingPath;			useTuneIn   	= _useTunein;			startMuted  	= _startMuted;			if( !useTuneIn ) tuneInID = _tuneInID;		}		public function destroy( e:Event = null ):void		{			stopVideoTimer();			removeProgressListener();			stopVideo();			clearVideoPlayer();			removeListeners();		}		public function init( e:Event = null ):void		{			setListeners();		}		private function get videoListManager():VideoListManager		{			if( !_videoListManager ) _videoListManager = new VideoListManager( useTuneIn, swfID );			return _videoListManager;		}		public function set tuneInID( value:String ):void		{			videoListManager.tuneInId = value;		}		/**		 * videos are added in the flash IDE		 * this method creates a generic object which adds		 * videos based on their date code in an array.		 */		public function addVideo( path:String = "", reportingID:String = "video", day:String = "default" ):void		{			if( !path )			{				throw new Error( "ALARM!!! :: No valid path in add video. Double Click Player requires a path to load video" );				return;			}			videoListManager.addVideo( day, path, "", "", reportingID );		}		/**		 * videos are added in the flash IDE		 * this method creates a generic object which adds		 * videos based on their date code in an array.		 */		public function addIntroOutroVideos( introVideo:int = -1, outroVideo:int = -1 ):void		{			preVideoVO = videoListManager.getCurrentVideo( introVideo );			postVideoVO = videoListManager.getCurrentVideo( outroVideo );		}        /**         * videos are added in the flash IDE         * this method creates a generic object which adds         * videos based on their date code in an array.         */        public function addVideos( pathHigh:String, pathMid:String = "", pathLow:String = "", reportingID:String = "video", day:String = "default" ):void        {            if( !pathLow && !pathMid && !pathHigh )            {                throw new Error( "ALARM!!! :: No valid path in add video. Double Click Player requires a path to load video" );                return;            }            videoListManager.addVideo( day, pathHigh, pathMid, pathLow, reportingID );        }		/**		 * add a percent value between 0 and 1 or a an actual time value, fires a method when video reaches that point of the video.		 */		public function addProgressEvent( time:String, videoID:String, method:Function = null, useTime:Boolean = false ):void		{			if( !progressEventManager ) progressEventManager = new ProgressEventManager();			progressEventManager.addProgressEvent( time, videoID, method, useTime );		}		public function resetProgressEvents():void		{			if( !progressEventManager ) return;			progressEventManager.resetEvents();		}		////////////////////////////////////////////// PUBLIC METHODS :: LOAD AND PLAY VIDEO //////////////////////////////////////////////////////////////////////////////////		/**		 * Loads and plays the first video on the list, sets initload value to false.		 */		public function playInitVideo( e:RmAdEvent = null ):void		{			if( broadcaster ) broadcaster.removeEventListener( RmAdEvent.TUNEIN_READY, playInitVideo );			if( useTuneIn && !TuneIn.isReady )			{				if( broadcaster ) broadcaster.addEventListener( RmAdEvent.TUNEIN_READY, playInitVideo );				return;			}			loadNewVideo( 0, false );		}		public function loadVideoWithPreRoll( vid:int ):void		{			// yeah, this will be fun :-(		}		private function checkForIntroVideo():void		{			//introVideoVO			//outroVideoVO		}		/**		 * Loads and plays video by video array position		 */		public function loadNewVideo( vid:int, initLoad:Boolean = true ):void		{			initVideoPlayed = initLoad;			videoNum = vid;            currentVideoVO = videoListManager.getCurrentVideo( videoNum );			videoPath = currentVideoVO.videoPath;			videoReportingID = currentVideoVO.videoReportingID;			setUpVideo();		}		/**		 * Loads and plays video by video array position		 */		public function loadVideoByID( id:String, initLoad:Boolean = true ):void		{			var vidObj:Object = videoListManager.getCurrentVideoByID( id );			if( !vidObj ) return;			initVideoPlayed = initLoad;			videoNum = vidObj.num;			currentVideoVO = vidObj.vo;			videoPath = currentVideoVO.videoPath;			videoReportingID = currentVideoVO.videoReportingID;			setUpVideo();		}		/**		 * Loads and plays video by video path and reporting id, doesn't need to have video list.		 */		public function loadAndPlay( path:String, reportingID:String = "default" ):void		{			trace( "LOAD AND PLAY VIDEO :: " + path );			isLoadAndPlay = true;			videoPath = path;			videoReportingID = reportingID;			setUpVideo();		}		/**		 * Loads and plays video by video path and reporting id, doesn't need to have video list.		 */		public function loadAndPause( path:String, reportingID:String = "default" ):void		{			isLoadAndPlay = true;			pauseAtStart = true;			videoPath = path;			videoReportingID = reportingID;			setUpVideo();		}		////////////////////////////////////////////// PUBLIC METHODS :: REPLAY VIDEO //////////////////////////////////////////////////////////////////////////////////		public function replayVideo( num:int = -1 ):void		{			trace( "\n\n\nREPLAY VIDEO CALLED :: LOOP COUNT: " + loopCount + "   LOOP NUM: " + loopVideoNum + "   NUM: " + num + "\n\n\n");			if( videoNum == num || num == -1 || isLoadAndPlay )			{				videoController.replay();			}			else			{				replayWithSound( num );			}			addProgressListener();			sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_PLAYING, { videoID:videoReportingID, playerID:playerID } ));		}		public function replayWithSound( num:int = -1 ):void		{			var vidNum:uint;			if( isLoadAndPlay )			{                videoController.replay();			}			else			{				if( num != -1 ) vidNum = num;				else if( replayVideoNum != -1 ) vidNum = replayVideoNum;				else if( videoNum ) vidNum = videoNum;				if( !videoListManager.getCurrentVideo( vidNum ) )				{					throw new Error("ALARM!!! ::: REPLAY WITH SOUND CALLED : VIDEO ARRAY IS NULL -- Make sure videos have been added before playing video." );					return;				}				loadNewVideo( vidNum );			}			sendVideoEvent( new RmVideoEvent( RmVideoEvent.PLAY_WITH_SOUND_CALLED, { videoID:videoReportingID, playerID:playerID }));			clearInitValues();		    unmuteAudio();		}		////////////////////////////////////////////// PUBLIC METHODS :: VIDEO CONTROLS COMMANDS //////////////////////////////////////////////////////////////////////////////////		public function playVideo( obj:Object = null ):void		{			if( obj && obj.data.playerID != playerID ) return;			if( !videoController )			{				trace("ALARM!!! ::: PLAY VIDEO CALLED : NO VIDEO CONTROLLER :: " + playerID );				return;			}			isPaused = false;			isPlaying = true;			addProgressListener();			videoController.play();			sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_PLAYING, { videoID:videoReportingID, playerID:playerID } ));		}        public function userMuteAudio():void        {            userUnmuted = false;            userMuted = true;            muteAudio();        }        public function userUnmuteAudio():void        {            userUnmuted = true;            userMuted = false;            unmuteAudio();        }		public function muteAudio( obj:Object = null ):void		{			if( obj && obj.data.playerID != playerID ) return;			videoController.mute();			isMuted = true;			sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_MUTED, { videoID:videoReportingID, playerID:playerID } ));		}		public function unmuteAudio( obj:Object = null ):void		{			if( obj && obj.data.playerID != playerID ) return;			checkForReplay();			videoController.unmute();			isMuted = false;            sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_UNMUTED, { videoID:videoReportingID, playerID:playerID } ));		}		public function pauseVideo( obj:Object = null ):void		{			trace( "DC VIDEO PLAYER PAUSE VIDEO CALLED :: " + obj.data.playerID + " != " + playerID  );			if( obj && obj.data.playerID != playerID ) return;			if( !videoController )			{				trace("ALARM!!! ::: PAUSE VIDEO CALLED : NO VIDEO CONTROLLER :: " + playerID );				return;			}			if( isPaused ) return;			isPaused = true;			videoController.pause();			sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_PAUSED, { videoID:videoReportingID, playerID:playerID } ));		}		public function stopVideo( obj:Object = null ):void		{			if( !videoController )			{				trace("ALARM!!! ::: STOP VIDEO CALLED : NO VIDEO CONTROLLER" );				return;			}			videoController.stop();			sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_STOPPED, { videoID:videoReportingID, playerID:playerID } ));		}		public function seekVideo(  obj:Object = null, _seek:Number = 0 ):void		{			if( obj && obj.data.playerID != playerID ) return;			if( !videoController )			{				trace("ALARM!!! ::: SEEK VIDEO CALLED : NO VIDEO CONTROLLER" );				return;			}			if ( obj ) _seek = obj.data.seekPos;			var _seekPos:Number = videoDuration * _seek;			videoController.seek( _seekPos );		}		/**		 * Sets video back to the start and pauses it.		 */		public function resetVideo():void		{			stopVideo();			seekVideo( null, 0 );		}		/**		 * Skips video to end, can be called from right click menu once i figure it out.		 */		public function skipVideo( e:Object = null, _skip:Number = .9 ):void		{			seekVideo( null, _skip );		}        public function setVideoSize( vidWidth:Number,  vidHeight:Number ):void        {            if( !videoPlayer ) return;            videoPlayer.width = vidWidth;            videoPlayer.height = vidHeight;        }		////////////////////////////////////////////// PRIVATE METHODS //////////////////////////////////////////////////////////////////////////////////		/**		 * Calls the set up video methods in order.		 */		private function setUpVideo():void		{			clearVideoPlayer();			initVideoPlayer();			initVideoController();			showBuffering();			setVideoEntry();			playVideo();			addProgressListener();		}		/**		 * Inits player, properties are set in the flash IDE, fired everytime a new video is loaded.		 */		private function initVideoPlayer():void		{			videoPlayer = new VideoPlayer();			videoPlayer.name = playerID;			videoPlayer.closeOnComplete = closeOnComplete;			videoPlayer.reportDuration = reportDuration;			videoPlayer.startPlayingAutomatically = false;			videoPlayer.width = videoTarget.width;			videoPlayer.height = videoTarget.height;			video = videoPlayer.getVideoObject();			video.smoothing = videoSmoothing;			videoTarget.addChild( videoPlayer );		}		/**		 * Inits the video controller, makes a new one every time a new video is loaded.		 */		private function initVideoController():void		{			videoController = videoPlayer.getCurrentVideoController();			videoController.setReportingIdentifier( "NO_ID" );            //videoController.setReportingIdentifier( videoReportingID );			videoController.setVideoObject( video );			videoController.setBufferTime( bufferTime );			videoController.setCloseOnComplete( closeOnComplete );			videoController.setEnabler( enabler );			videoController.addEventListener( StudioVideoEvent.COMPLETE,                		videoComplete );			videoController.addEventListener( StudioVideoEvent.NET_STREAM_META_DATA,    		onMetaData );			videoController.addEventListener( StudioVideoEvent.NET_STREAM_CUE_POINT,    		onCuePoint );			videoController.addEventListener( StudioVideoEvent.PLAY,                    		studioEventVideoPlaying );			videoController.addEventListener( StudioVideoEvent.REPLAY,                  		studioEventVideoPlaying );			videoController.addEventListener( StudioVideoEvent.RESUME,                  		studioEventVideoPlaying );			videoController.addEventListener( StudioVideoEvent.STOP,                    		studioEventVideoStopped );			videoController.addEventListener( StudioVideoEvent.PAUSE,                   		studioEventVideoStopped );			videoController.addEventListener( StudioVideoEvent.CONNECTION_ERROR,                onPlayerError );			videoController.addEventListener( StudioVideoEvent.NETSTREAM_PLAY_STREAMNOTFOUND,   onPlayerError );		}		/**		 * Creates the video entry, decides to use streaming or not based on the streamVideo property.		 */		private function setVideoEntry():void		{            if( !videoController || !videoPath )			{				trace("ALARM!!! ::: SET VIDEO ENTRY CALLED : NO VIDEO CONTROLLER OR VIDEO PATH" );				return;			}            var highPath:String = '';            var midPath:String = '';            var lowPath:String = '';            if( currentVideoVO )            {                // add video used                highPath = currentVideoVO.videoPathHigh;                midPath  = currentVideoVO.videoPathMid;                lowPath  = currentVideoVO.videoPathLow;            }            else            {                // load and play or load and pause used                highPath = videoPath;            }			if( streamVideo )			{				videoEntry = new VideoEntry( streamPath + highPath, streamPath + midPath, streamPath + lowPath, SmartStreamingConnection );			}			else			{				videoEntry = new VideoEntry( highPath, midPath, lowPath );			}			setReportingID();			videoController.addVideoEntry( videoEntry );		}		/**		 * removes and destroys current videoPlayer object.		 */		private function clearVideoPlayer( e:Event = null ):void		{			if( videoController ) videoController.unload();			if( stream ) stream.close();			if( video ) video.clear();			if( videoPlayer )			{				videoPlayer.unload();				if( videoTarget.contains( videoPlayer )) videoTarget.removeChild( videoPlayer );			}			videoController = null;			video = null;			stream = null;			videoProgressEvent = null;			progressEvents_obj = null;			sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_CLEARED, { videoID:videoReportingID, playerID:playerID }));		}		/**		 * Loops video based on the loopVideoNum value.		 */		private function loopVideo():void		{			trace( "\n\n\nLOOP VIDEO CALLED :: LOOP COUNT: " + loopCount + "   LOOP NUM: " + loopVideoNum + "\n\n\n");			if( loopCount < loopVideoNum )			{				replayVideo();				loopCount++;			}			else			{				loopCount = 0;				loopVideoNum = -1;				sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_LOOP_COMPLETE, { videoID:videoReportingID, playerID:playerID }));			}		}		/**		 * When unmute is called, it will check if it was started muted and the first video, and replay with sound.		 */		private function checkForReplay( e:StudioVideoEvent = null ):void		{			if( e && videoController != e.currentTarget ) return;			if( !initVideoPlayed && startMuted )			{				clearInitValues();				replayWithSound();			}		}		private function addProgressListener( e:StudioVideoEvent = null ):void		{			if( !videoPlayer ) return;			videoPlayer.removeEventListener( Event.ENTER_FRAME, updateVideo );			videoPlayer.addEventListener( Event.ENTER_FRAME, updateVideo );		}		private function removeProgressListener( e:StudioVideoEvent = null ):void		{			if( !videoPlayer ) return;			videoPlayer.removeEventListener( Event.ENTER_FRAME, updateVideo );		}		private function studioEventVideoStopped( e:StudioVideoEvent ):void		{			stopVideoTimer();			removeProgressListener();		}		private function studioEventVideoPlaying( e:StudioVideoEvent ):void		{			startVideoTimer();			addProgressListener();		}		/**		 * set properties once the video loads and gets meta data.		 */		private function onMetaData( e:StudioVideoEvent ):void		{			videoDuration = e.info.duration as Number;			if( pauseAtStart )			{				pauseVideo();				sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_LOADED, { videoID:videoReportingID, playerID:playerID } ));			}			else			{				videoPlaying = true;				sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_STARTED, { videoID:videoReportingID, playerID:playerID } ));			}			// setting stream value after meta data event to make sure it's there.			stream = videoController.getNetStream();			addProgressListener();			hideBuffering();			isVideoMuted();		}		private function onCuePoint( e:StudioVideoEvent ):void		{			sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_ON_CUEPOINT, {videoID:videoReportingID, playerID:playerID, pointObj:e.info} ));		}		/**		 * Mutes video if startMuted is set and initVideoPlayed is false.		 */		private function isVideoMuted():void		{			if(( !initVideoPlayed && startMuted ) || userMuted )			{				muteAudio();			}			else			{				unmuteAudio();			}		}		////////////////////////////////////////////// VIDEO EVENTS //////////////////////////////////////////////////////////////////////////////////		private function setReportingID():void		{			videoController.setReportingIdentifier( videoReportingID );			//sendVideoEvent( new RmVideoEvent( RmVideoEvent.UPDATE_VIDEO_ID, { videoID:videoReportingID, playerID:playerID }));		}		private function hideBuffering():void		{			sendVideoEvent( new RmVideoEvent( RmVideoEvent.HIDE_BUFFERING, { videoID:videoReportingID, playerID:playerID } ));		}		private function showBuffering():void		{			sendVideoEvent( new RmVideoEvent( RmVideoEvent.SHOW_BUFFERING, { videoID:videoReportingID, playerID:playerID } ));		}		private function videoComplete( e:StudioVideoEvent ):void		{			trace( "\n\n\nVIDEO COMPLETE CALLED :: LOOP COUNT: " + loopCount + "   LOOP NUM: " + loopVideoNum + "\n\n\n");			clearInitValues();			handleVideoCompleteProps();			removeProgressListener();			stopVideoTimer();			sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_COMPLETE, { videoID:videoReportingID, playerID:playerID } ));		}		private function onPlayerError( e:StudioVideoEvent ):void		{			sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_ERROR, { videoID:videoReportingID, playerID:playerID } ));		}		/**		 * Updates progress bar load bar, only works on progressive loads.		 */		private function updateLoad():void		{			var bytesLoaded:Number = ( stream ) ? stream.bytesLoaded / stream.bytesTotal : 0;			sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_BYTES_LOADED, { bytesLoaded:bytesLoaded, videoID:videoReportingID, playerID:playerID }));		}		/**		 * Updates video progress bar.		 */		private function updateProgress():void		{			var time:Number = ( stream && stream.time ) ? stream.time : 0;			var pos:Number = time / ( videoDuration || 0 );			checkForProgressCallback( pos );			sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_PROGRESS, { videoID:videoReportingID, playerID:playerID, progress:pos }));			var event:RmVideoEvent;			var eventType:String;			if( pos < .25 )         eventType = RmVideoEvent.VIDEO_0_PERCENT;			else if( pos < .5 )     eventType = RmVideoEvent.VIDEO_25_PERCENT;			else if( pos < .75 )    eventType = RmVideoEvent.VIDEO_50_PERCENT;			else if( pos < .97 )    eventType = RmVideoEvent.VIDEO_75_PERCENT;			else                    eventType = RmVideoEvent.VIDEO_100_PERCENT;			if( eventType != videoProgressEvent )			{				event = new RmVideoEvent( eventType, { videoID:videoReportingID, playerID:playerID } );				sendVideoEvent( event );				videoProgressEvent = eventType;			}		}		private function checkForProgressCallback( _pos:Number ):void		{			if( !progressEventManager || !progressEventManager.getProgressList( videoReportingID )) return;			var eventList:Array = progressEventManager.getProgressList( videoReportingID );			var obj:Object;			var pos:Number;			var length:uint = eventList.length;            var time:Number = ( stream && stream.time ) ? stream.time : 0;			for( var i:uint = 0; i < length; i++ )			{				obj = eventList[i];				pos = ( obj.useTime ) ? time : _pos;				if( pos >= obj.time && !obj.fired )				{					obj.fired = true;					obj.callback( obj.value );				}			}		}		/**		 * Fires all outgoing events on both the player and the event broadcaster.		 */		private function sendVideoEvent( event:RmVideoEvent ):void        {			if( event.type != RmVideoEvent.VIDEO_PROGRESS && event.type != RmVideoEvent.VIDEO_BYTES_LOADED ) reportVideoEvent( event.type );			dispatchEvent( event );			if( !ignoreControls )			{				NotificationManager.sendNotification( event.type, event.data );			}		}		private function reportVideoEvent( value:String ):void		{			dispatchEvent( new RmVideoEvent( RmVideoEvent.VIDEO_UPDATED, { event:value, videoID:videoReportingID, playerID:playerID } ));			if( !DCData ) return;			var event:String = DCData.VIDEO_EVENT_REF[value];			if( !event ) return;			var ctr:String = DCData.VIDPLAYER_COUNTER_DATA.split( DCData.VIDPLAYER_ID ).join( videoReportingID ).split( DCData.VIDPLAYER_ACTION ).join( event );			DCTrackingManager.trackCounter( ctr );			engagedVideoTracking( value );		}		private function engagedVideoTracking( event:String ):void		{			if( !isEngaged ) return;			switch( event )			{				case RmVideoEvent.VIDEO_50_PERCENT:					DCTrackingManager.trackCounter( DCData.CTR_ENGAGED_VIDEO_MIDPOINT );					break;				case RmVideoEvent.VIDEO_COMPLETE:					DCTrackingManager.trackCounter( DCData.CTR_ENGAGED_VIDEO_COMPLETE );					break;				case RmVideoEvent.VIDEO_PLAYING:					DCTrackingManager.trackCounter( DCData.CTR_ENGAGED_VIDEO_VIEW );					break;			}		}		private function startVideoTimer():void		{			if( !DCData ) return;			videoTimerID = DCData.VIDPLAYER_TMR_DATA.split( DCData.VIDPLAYER_ID ).join( videoReportingID );			if( videoTimerID && videoTimerID != "" ) DCTrackingManager.timerStart( videoTimerID );			if( isEngaged ) DCTrackingManager.timerStart( DCData.TMR_ENGAGED_VIDEO_VIEW );		}		private function stopVideoTimer():void		{			if( !DCData ) return;			if( videoTimerID ) DCTrackingManager.timerStop( videoTimerID );			if( isEngaged ) DCTrackingManager.timerStop( DCData.TMR_ENGAGED_VIDEO_VIEW );		}		////////////////////////////////////////////// PRIVATE METHODS //////////////////////////////////////////////////////////////////////////////////		/**		 * Fired on enter frame, updates all enter frame methods.		 */		private function updateVideo( e:Event ):void		{			e.stopImmediatePropagation();			updateProgress();			updateLoad();		}		/**		 * Clears all initial player values once first video is complete or user input.		 */		private function clearInitValues():void		{			isPlaying		= false;			initVideoPlayed = true;		}		/**		 * On video complete checks for looping or close.		 */		private function handleVideoCompleteProps():void		{			if( closeOnComplete )    destroy();			if( loopVideoNum != -1 ) loopVideo();		}		private function setListeners():void		{			videoTarget.addEventListener( Event.REMOVED_FROM_STAGE, destroy );			if( ignoreControls ) return;			NotificationManager.regisiterNotificationInterest( RmVideoEvent.MUTE_VIDEO, muteAudio );			NotificationManager.regisiterNotificationInterest( RmVideoEvent.UNMUTE_VIDEO, unmuteAudio );			NotificationManager.regisiterNotificationInterest( RmVideoEvent.PAUSE_VIDEO, pauseVideo );			NotificationManager.regisiterNotificationInterest( RmVideoEvent.PLAY_VIDEO, playVideo );			NotificationManager.regisiterNotificationInterest( RmVideoEvent.STOP_VIDEO, stopVideo );			NotificationManager.regisiterNotificationInterest( RmVideoEvent.SEEK_VIDEO, seekVideo );		}		private function removeListeners():void		{			if( videoTarget ) videoTarget.removeEventListener( Event.REMOVED_FROM_STAGE, destroy );			NotificationManager.removeNotificationInterest( RmVideoEvent.MUTE_VIDEO, muteAudio );			NotificationManager.removeNotificationInterest( RmVideoEvent.UNMUTE_VIDEO, unmuteAudio );			NotificationManager.removeNotificationInterest( RmVideoEvent.PAUSE_VIDEO, pauseVideo );			NotificationManager.removeNotificationInterest( RmVideoEvent.PLAY_VIDEO, playVideo );			NotificationManager.removeNotificationInterest( RmVideoEvent.STOP_VIDEO, stopVideo );			NotificationManager.removeNotificationInterest( RmVideoEvent.SEEK_VIDEO, seekVideo );		}	}}