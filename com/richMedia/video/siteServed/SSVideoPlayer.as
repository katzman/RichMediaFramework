/** SSVideoPlayer * ------------------------------------------------------------------------------------- * @ description: wrapper for the site served video player. * @ usage: refer to documentation for usage. * @ developer: Neil Katz * @ version: 1.0.0  02.13.2014 * ------------------------------------------------------------------------------------- * */package com.richMedia.video.siteServed{	import com.richMedia.managers.ProgressEventManager;	import com.richMedia.components.TuneIn;	import com.richMedia.managers.VideoListManager;	import com.richMedia.constants.Constants;	import com.richMedia.events.RmAdEvent;	import com.richMedia.events.EventBroadcaster;	import com.richMedia.events.RmVideoEvent;	import flash.display.MovieClip;	import flash.events.AsyncErrorEvent;	import flash.events.Event;	import flash.events.IOErrorEvent;	import flash.events.NetStatusEvent;	import flash.events.SecurityErrorEvent;	import flash.events.EventDispatcher;	import flash.media.SoundTransform;	import flash.media.Video;	import flash.net.NetConnection;	import flash.net.NetStream;	[Event(name="videoReady"			,type="com.richMedia.events.RmVideoEvent")]	[Event(name="videoError"			,type="com.richMedia.events.RmVideoEvent")]	[Event(name="videoCleared"			,type="com.richMedia.events.RmVideoEvent")]	[Event(name="videoStarted"			,type="com.richMedia.events.RmVideoEvent")]	[Event(name="videoComplete"			,type="com.richMedia.events.RmVideoEvent")]	[Event(name="videoLoopComplete"		,type="com.richMedia.events.RmVideoEvent")]	[Event(name="videoProgress"			,type="com.richMedia.events.RmVideoEvent")]	[Event(name="videoPlaying"			,type="com.richMedia.events.RmVideoEvent")]	[Event(name="videoPaused"			,type="com.richMedia.events.RmVideoEvent")]	[Event(name="videoStopped"			,type="com.richMedia.events.RmVideoEvent")]	[Event(name="videoUnmuted"			,type="com.richMedia.events.RmVideoEvent")]	[Event(name="videoMuted"			,type="com.richMedia.events.RmVideoEvent")]	[Event(name="video_0_percent"		,type="com.richMedia.events.RmVideoEvent")]	[Event(name="video_25_percent"		,type="com.richMedia.events.RmVideoEvent")]	[Event(name="video_50_percent"		,type="com.richMedia.events.RmVideoEvent")]	[Event(name="video_75_percent"		,type="com.richMedia.events.RmVideoEvent")]	[Event(name="video_100_percent"		,type="com.richMedia.events.RmVideoEvent")]	[Event(name="showBuffering"			,type="com.richMedia.events.RmVideoEvent")]	[Event(name="hideBuffering"			,type="com.richMedia.events.RmVideoEvent")]	[Event(name="playWithSoundCalled"	,type="com.richMedia.events.RmVideoEvent")]	[Event(name="videoOnCuepoint"		,type="com.richMedia.events.RmVideoEvent")]	[Event(name="videoBytesLoaded"		,type="com.richMedia.events.RmVideoEvent")]	[Event(name="videoUpdated"		    ,type="com.richMedia.events.RmVideoEvent")]	public class SSVideoPlayer extends EventDispatcher	{		////////////////////////////////////////////// PUBLIC VARS //////////////////////////////////////////////////////////////////////////////////		public var bufferTime		    : Number = 1;		public var closeOnComplete	    : Boolean = false;		public var startMuted		    : Boolean = false;		public var ignoreControls       : Boolean = false;		public var streamVideo		    : Boolean = false;		public var initVideoPlayed      : Boolean = false;		public var addSkipMenuItem      : Boolean = false;		public var videoSmoothing	    : Boolean = true;		public var pauseAtStart		    : Boolean = false;		public var useVideoCuePoints	: Boolean = false;		public var loopVideoNum         : int = -1;		public var loopCount            : int = 0;		public var replayVideoNum       : int;		public var streamPath		    : String = "";		public var playerID             : String = Constants.PLAYER_DEFAULT_ID;		public var swfID                : String = Constants.SWF_DEFAULT_ID;		////////////////////////////////////////////// PRIVATE VARS //////////////////////////////////////////////////////////////////////////////////		private var videoPlaying		: Boolean = false;  ////// variable to know if the video is playing		private var initialLoad			: Boolean = false;	////// variable used for first video play		private var videoDuration		: Number;		private var videoProgressEvent  : String;		private var videoNum			: int = 0;		private var videoPath           : String;		private var videoReportingID    : String;		private var _tuneInID           : String = Constants.TUNEIN_DEFAULT_ID;		private var listener_obj	    : Object;		private var metaData_obj	    : Object;		private var progressEvents_obj 	: Object;		private var _videoListManager   : VideoListManager;		private var progressEventManager: ProgressEventManager;		private var broadcaster         : EventBroadcaster;		private var stream			    : NetStream;		private var connection		    : NetConnection;		private var video			    : Video;		private var videoTarget         : MovieClip;		private var menuTarget          : MovieClip;		private var isPaused            : Boolean;		private var isMuted             : Boolean;		private var useTuneIn           : Boolean;		private var isLoadAndPlay		: Boolean;		/**		 * DCVideoPlayer Constructor		 * @param: _videoPlayer: is the DC VideoPlayer Object that is on the stage.		 * @param: _startMuted: starts video with no sound.		 * @param: _useTunein: use tunein component data to retrieve date coded video.		 * @param: _streaming: just tells it to use streaming or not.		 * @param: _streamingPath: is used if you have a separate path to be added for streaming, can also be added to the video path when they are added.		 */		public function SSVideoPlayer( _videoTarget:MovieClip, _startMuted:Boolean = true, _useTunein:Boolean = false, _streaming:Boolean = false, _streamingPath:String = "" )		{			trace("***************************************************");			trace("******** SITE SERVED VIDEO WRAPPER V 2.0.0 ********");			trace("***************************************************");			videoTarget = _videoTarget;			streamVideo = _streaming;			streamPath  = _streamingPath;			useTuneIn   = _useTunein;			startMuted  = _startMuted;			if( !useTuneIn ) tuneInID = _tuneInID;		}		public function init( e:Event = null ):void		{			setListeners();			sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_READY, {videoID:videoReportingID, playerID:playerID} ));		}		public function destroy( e:Event = null ):void		{			removeProgressListener();			stopVideo();			clearVideoPlayer();			removeListeners();			videoTarget         = null;			streamPath          = null;			progressEvents_obj  = null;		}		private function get videoListManager():VideoListManager		{			if( !_videoListManager ) _videoListManager = new VideoListManager( useTuneIn, swfID );			return _videoListManager;		}		public function set tuneInID( value:String ):void		{			videoListManager.tuneInId = value;		}        /**         * videos are added in the flash IDE         * this method creates a generic object which adds         * videos based on their date code in an array.         */        public function addVideo( pathHigh:String = "", reportingID:String = "video", day:String = "default" ):void        {            if( !pathHigh )            {                throw new Error( "ALARM!!! :: No valid path in add video. Double Click Player requires a path to load video" );                return;            }            videoListManager.addVideo( day, pathHigh, "", "", reportingID );        }        /**         * videos are added in the flash IDE         * this method creates a generic object which adds         * videos based on their date code in an array.         */        public function addVideos( pathHigh:String, pathMid:String = "", pathLow:String = "", reportingID:String = "video", day:String = "default" ):void        {            if( !pathLow && !pathMid && !pathHigh )            {                throw new Error( "ALARM!!! :: No valid path in add video. Double Click Player requires a path to load video" );                return;            }            videoListManager.addVideo( day, pathHigh, pathMid, pathLow, reportingID );        }        /**		 * add a percent value between 0 and 1 or a an actual time value, that fires a method when video reaches that point of the video.		 */		public function addProgressEvent( time:String, videoID:String, method:Function = null, useTime:Boolean = false ):void		{			if( !progressEventManager ) progressEventManager = new ProgressEventManager();			progressEventManager.addProgressEvent( time, videoID, method, useTime );		}        public function resetProgressEvents():void        {            if( !progressEventManager ) return;            progressEventManager.resetEvents();        }		////////////////////////////////////////////// PUBLIC METHODS :: LOAD AND PLAY VIDEO //////////////////////////////////////////////////////////////////////////////////		/**		 * Loads and plays the first video on the list, sets initload value to false.		 */		public function playInitVideo( e:RmAdEvent = null ):void		{			trace( "PLAY INIT VIDEO :: " + TuneIn.isReady + " EVENT :: " + e );			broadcaster.removeEventListener( RmAdEvent.TUNEIN_READY, playInitVideo );			if( useTuneIn && !TuneIn.isReady )			{				broadcaster.addEventListener( RmAdEvent.TUNEIN_READY, playInitVideo );				return;			}			loadNewVideo( 0, false );		}		/**		 * Loads and plays video by video array position		 */		public function loadNewVideo( vid:int, initLoad:Boolean = true ):void		{			trace( "LOAD NEW VIDEO :: " + vid );			initVideoPlayed = initLoad;			removeProgressListener();			setVideoProps( vid );			setUpVideo();		}		/**		 * Loads and plays video by video path and reporting id, doesn't need to have video list.		 */		public function loadAndPlay( path:String, reportingID:String = "default" ):void		{			removeProgressListener();			isLoadAndPlay = true;			setVideoProps( -1, path, reportingID );			setUpVideo();		}		/**		 * Loads and plays video by video path and reporting id, doesn't need to have video list.		 */		public function loadAndPause( path:String, reportingID:String = "default" ):void		{			setVideoProps( -1, path, reportingID );			pauseAtStart = true;			setUpVideo();		}		////////////////////////////////////////////// PUBLIC METHODS :: REPLAY VIDEO //////////////////////////////////////////////////////////////////////////////////		public function replayVideo( num:int = -1 ):void		{			trace( "\n\n\nREPLAY VIDEO CALLED :: LOOP COUNT: " + loopCount + "   LOOP NUM: " + loopVideoNum + "   NUM: " + num + "\n\n\n");			if( videoNum == num || num == -1 || isLoadAndPlay )			{				seekVideo( null, 0 );				stream.play( videoPath );			}			else			{				replayWithSound( num );			}			addProgressListener();			sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_PLAYING, { videoID:videoReportingID, playerID:playerID } ));		}		public function replayWithSound( num:int = -1 ):void		{			var vidNum:uint;			if( isLoadAndPlay )			{				replayVideo();			}			else			{				if( num != -1 ) vidNum = num;				else if( replayVideoNum != -1 ) vidNum = replayVideoNum;				else if( videoNum ) vidNum = videoNum;				loadNewVideo( vidNum );			}			sendVideoEvent( new RmVideoEvent( RmVideoEvent.PLAY_WITH_SOUND_CALLED, {videoID:videoReportingID, playerID:playerID}));			clearInitValues();			//unmuteAudio();		}		////////////////////////////////////////////// PUBLIC METHODS :: VIDEO CONTROLS COMMANDS //////////////////////////////////////////////////////////////////////////////////		public function playVideo( e:RmVideoEvent = null ):void		{			if( e && e.data.playerID != playerID ) return;			trace("\n\n\nPLAY VIDEO CALLED ::: " + stream + "   VIDEO PATH ::: " + videoPath + "   IS PAUSED ::: " + isPaused + "\n\n\n" );			if( !stream )			{				trace("ALARM!!! ::: PLAY VIDEO CALLED : NO VIDEO STREAM" );				return;			}			if( isPaused )			{				stream.resume();			}			else			{				stream.play( videoPath );			}			isPaused = false;			addProgressListener();			sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_PLAYING, {videoID:videoReportingID, playerID:playerID} ));		}		public function setVideoVolume(_vol:Number):void		{			var _sndTransform:SoundTransform = new SoundTransform(_vol);			trace( "STREAM :: " + stream );			stream.soundTransform = _sndTransform;		}		public function muteAudio( e:RmVideoEvent = null ):void		{			if( e && e.data.playerID != playerID ) return;			setVideoVolume( 0 );			sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_MUTED, {videoID:videoReportingID, playerID:playerID} ));		}		public function unmuteAudio( e:RmVideoEvent = null ):void		{			if( e && e.data.playerID != playerID ) return;			setVideoVolume( 1 );			sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_UNMUTED, {videoID:videoReportingID, playerID:playerID} ));			checkForReplay();		}		public function pauseVideo( e:RmVideoEvent = null ):void		{			if( e && e.data.playerID != playerID ) return;			if( !stream )			{				trace("ALARM!!! ::: PAUSE VIDEO CALLED : NO VIDEO STREAM" );				return;			}			if( isPaused ) return;			isPaused = true;			removeProgressListener();			stream.pause();			sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_PAUSED, {videoID:videoReportingID, playerID:playerID} ));		}		public function stopVideo( e:RmVideoEvent = null ):void		{			trace( "STOP VIDEO CALLED" );			if( !stream )			{				trace("ALARM!!! ::: STOP VIDEO CALLED : NO VIDEO STREAM" );				return;			}			removeProgressListener();			stream.close();			sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_STOPPED, {videoID:videoReportingID, playerID:playerID} ));		}		public function seekVideo( e:RmVideoEvent, _seek:Number = 0 ):void		{			if( e && e.data.playerID != playerID ) return;			if( !stream )			{				trace("ALARM!!! ::: SEEK VIDEO CALLED : NO VIDEO CONTROLLER" );				return;			}			if ( e ) _seek = e.data.seekPos;			var _seekPos:Number = videoDuration * _seek;			stream.seek( _seekPos );		}		/**		 * Sets video back to the start and pauses it.		 */		public function resetVideo():void		{			seekVideo( null, 0 );			pauseVideo();		}		/**		 * Skips video to end, can be called from right click menu once i figure it out.		 */		public function skipVideo( _skip:Number = .9 ):void		{			seekVideo( null, _skip );		}		/**		 * removes and destroys current videoPlayer object.		 */		public function clearVideoPlayer( e:Event = null ):void		{			if( stream ) stream.close();			if( connection ) connection.close();			if( videoTarget && video && videoTarget.contains( video )) videoTarget.removeChild ( video );			connection          = null;			video               = null;			stream              = null;			videoProgressEvent  = null;			isPaused            = false;			sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_CLEARED, {videoID:videoReportingID, playerID:playerID} ));		}		////////////////////////////////////////////// PRIVATE METHODS //////////////////////////////////////////////////////////////////////////////////		/**		 * sets the video path, video id, and reporting id.		 */		private function setVideoProps( _pos:int, _path:String = "", _reportingID:String = "" ):void		{			if( _pos == -1 && _path == "" )			{				trace("ALARM!!! ::: NO VALID VIDEO PATH OR ARRAY POSITION" );				return;			}			var videoObj:Object;			if( _pos != -1 )			{				if( !videoListManager.getCurrentVideo( _pos ) )				{					throw new Error("ALARM!!! ::: SET VIDEO PROPERTIES CALLED : VIDEO ARRAY IS NULL -- Make sure videos have been added before playing video :: " + _pos );					return;				}				videoNum 			= _pos;				videoObj 			= videoListManager.getCurrentVideo( videoNum );				videoPath 			= videoObj.videoPath;				videoReportingID 	= videoObj.videoReportingID;			}			else			{				videoPath 			= _path;				videoReportingID 	= _reportingID;			}			setReportingID();		}		/**		 * Calls the set up video methods in order.		 */		private function setUpVideo():void		{			//stopVideo();			//clearVideoPlayer();			showBuffering();			initVideoPlayer();		}		/**		 * Inits player, properties are set in the flash IDE, fired everytime a new video is loaded.		 */		private function initVideoPlayer():void		{			//clearVideoPlayer();			listener_obj = {};			metaData_obj = {};			connection = new NetConnection();			connection.client = this;			connection.addEventListener( IOErrorEvent.IO_ERROR,             connectionStatus );			connection.addEventListener( NetStatusEvent.NET_STATUS,         connectionStatus );			connection.addEventListener( AsyncErrorEvent.ASYNC_ERROR,       asyncHandler );			connection.addEventListener( SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler );			if( !streamVideo )			{				connection.connect( null );			}			else			{				connection.connect( streamPath );			}		}		private function securityErrorHandler( event:SecurityErrorEvent ):void		{			trace("SecurityErrorEvent: " + event);			onPlayerError();		}		private function asyncHandler( event:AsyncErrorEvent ):void		{			trace("AsyncErrorEvent: " + event );			onPlayerError();		}		private function connectionStatus( e:Event ):void		{			trace( "CONNECTION STATUS EVENT: " + e['info']['code'] );			////trace_r( e );			switch ( e['info']['code'] )			{				case "NetConnection.Connect.Success":					setStream();					break;				case "NetStream.Play.StreamNotFound":					onPlayerError();					break;			}		}		private function setStream():void		{			listener_obj = {};			stream = new NetStream ( connection );			stream.addEventListener( NetStatusEvent.NET_STATUS, videoStatus );			stream.addEventListener( IOErrorEvent.IO_ERROR, videoError );			listener_obj.onMetaData = onMetaData;			listener_obj.onCuePoint = onCuePoint;			stream.bufferTime 		= bufferTime;			stream.client 			= listener_obj;			video = new Video();			video.smoothing         = videoSmoothing;			video.width 	        = videoTarget.width;			video.height 	        = videoTarget.height;			video.attachNetStream( stream );			videoTarget.addChild ( video );			playVideo();		}		public function onBWDone( obj:Object = null ):void		{			trace("ON BWDONE: " + obj );		}		/**		 * Loops video based on the loopVideoNum value.		 */		private function loopVideo():void		{			if( loopCount < loopVideoNum )			{				loopCount++;				replayVideo();			}			else			{				loopCount = 0;				loopVideoNum = -1;				sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_LOOP_COMPLETE, {videoID:videoReportingID, playerID:playerID} ));			}		}		/**		 * When unmute is called, it will check if it was started muted and the first video, and replay with sound.		 */		private function checkForReplay():void		{			if( !initVideoPlayed && startMuted )			{				replayWithSound();				clearInitValues();			}		}		private function addProgressListener():void		{			removeProgressListener();			videoTarget.addEventListener( Event.ENTER_FRAME, updateVideo );		}		private function removeProgressListener():void		{			videoTarget.removeEventListener( Event.ENTER_FRAME, updateVideo );		}		private function videoError ( e:Event ):void		{			trace ( "\n\n\nVIDEO ERROR: ");			////trace_r ( e );		}		/**		 * set properties once the video loads and gets meta data.		 */		private function onMetaData( _data:Object ):void		{			trace( "\n\n\nON META DATA CALLED\n\n\n" );			////trace_r( _data );			metaData_obj = _data;			videoDuration = metaData_obj.duration as Number;			videoPlaying = true;			sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_STARTED, {videoID:videoReportingID, playerID:playerID} ));			if( pauseAtStart ) pauseVideo();			hideBuffering();			isVideoMuted();		}		private function onCuePoint(infoObject:Object):void		{			sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_ON_CUEPOINT, {videoID:videoReportingID, playerID:playerID, pointObj:infoObject} ));		}		/**		 * Mutes video if startMuted is set and initVideoPlayed is false.		 */		private function isVideoMuted():void		{			if( !initVideoPlayed && startMuted ) muteAudio();			else unmuteAudio();		}		////////////////////////////////////////////// VIDEO EVENTS //////////////////////////////////////////////////////////////////////////////////		private function setReportingID():void		{			sendVideoEvent( new RmVideoEvent( RmVideoEvent.UPDATE_VIDEO_ID, { videoID:videoReportingID, playerID:playerID }));		}		private function hideBuffering():void		{			sendVideoEvent( new RmVideoEvent( RmVideoEvent.HIDE_BUFFERING, {videoID:videoReportingID, playerID:playerID} ));		}		private function showBuffering():void		{			sendVideoEvent( new RmVideoEvent( RmVideoEvent.SHOW_BUFFERING, {videoID:videoReportingID, playerID:playerID} ));		}		private function videoComplete():void		{			if( videoDuration - stream.time > 1 ) return;			clearInitValues();			handleVideoCompleteProps();			removeProgressListener();			sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_COMPLETE, {videoID:videoReportingID, playerID:playerID} ));		}		private function onPlayerError():void		{			sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_ERROR, {videoID:videoReportingID, playerID:playerID} ));		}		/**		 * Updates progress bar load bar, only works on progressive loads.		 */		private function updateLoad():void		{			var bytesLoaded:Number = ( stream ) ? stream.bytesLoaded / stream.bytesTotal : 0;			sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_BYTES_LOADED, { videoID:videoReportingID, bytesLoaded:bytesLoaded, playerID:playerID }));		}		/**		 * Updates video progress bar.		 */		private function updateProgress():void		{			var time:Number = ( stream && stream.time ) ? stream.time : 0;			var pos:Number = time / ( videoDuration || 0 );			if( pos == Infinity ) pos = 0;			sendVideoEvent( new RmVideoEvent( RmVideoEvent.VIDEO_PROGRESS, { videoID:videoReportingID, playerID:playerID, progress:pos }));			sendProgressEvent( pos );			checkForProgressCallback( pos );		}		private function checkForProgressCallback( _pos:Number = 0 ):void		{			if( !progressEventManager || !progressEventManager.getProgressList( videoReportingID )) return;			var eventList:Array = progressEventManager.getProgressList( videoReportingID );			var obj:Object;			var pos:Number;			var length:uint = eventList.length;			for( var i:uint = 0; i < length; i++ )			{				obj = eventList[i];				pos = ( obj.useTime ) ? stream.time : _pos;				if( pos >= obj.time && !obj.fired )				{					obj.fired = true;					obj.callback( obj.value );				}			}		}		private function sendProgressEvent( pos:Number ):void		{			var event:RmVideoEvent;			var eventType:String;			if( pos < .25 )         eventType = RmVideoEvent.VIDEO_0_PERCENT;			else if( pos < .5 )     eventType = RmVideoEvent.VIDEO_25_PERCENT;			else if( pos < .75 )    eventType = RmVideoEvent.VIDEO_50_PERCENT;			else if( pos < .97 )    eventType = RmVideoEvent.VIDEO_75_PERCENT;			else                    eventType = RmVideoEvent.VIDEO_100_PERCENT;			if( eventType != videoProgressEvent )			{				event = new RmVideoEvent( eventType, { videoID:videoReportingID, playerID:playerID } );				sendVideoEvent( event );				videoProgressEvent = eventType;			}		}		/**		 * Fires all outgoing events on both the player and the event broadcaster.		 */		private function sendVideoEvent( event:RmVideoEvent )		{			dispatchEvent( event );			dispatchEvent( new RmVideoEvent( RmVideoEvent.VIDEO_UPDATED, { event:event.type, videoID:videoReportingID, playerID:playerID } ));			if( ignoreControls ) return;			var event2:RmVideoEvent;			event2 = new RmVideoEvent( event.type, event.data );			broadcaster.dispatchEvent( event2 );		}		////////////////////////////////////////////// PRIVATE METHODS //////////////////////////////////////////////////////////////////////////////////		/**		 * Fired on enter frame, updates all enter frame methods.		 */		private function updateVideo( e:Event ):void		{			e.stopImmediatePropagation();			updateProgress();			updateLoad();		}		public function videoStatus(e:NetStatusEvent):void		{			trace( "VIDEO STATUS :: " + e.info.code );			var _videoEvent:RmVideoEvent;			switch (e.info.code)			{				case "NetStream.Play.NoSupportedTrackFound":				case "NetStream.Play.StreamNotFound":				case "NetStream.Play.Failed":					_videoEvent = new RmVideoEvent( RmVideoEvent.VIDEO_ERROR, {videoID:videoReportingID, playerID:playerID} );					break;				case "NetStream.Seek.InvalidTime":					trace("seeked too far ahead");					break;				case "NetStream.Seek.Notify":					break;				case "NetStream.Pause.Notify":					_videoEvent = new RmVideoEvent( RmVideoEvent.VIDEO_PAUSED, {videoID:videoReportingID, playerID:playerID} );					break;				case "NetStream.Unpause.Notify":					_videoEvent = new RmVideoEvent( RmVideoEvent.VIDEO_RESUMED, {videoID:videoReportingID, playerID:playerID} );					break;				case "NetStream.Buffer.Empty":				case "NetStream.Play.Start":					_videoEvent = new RmVideoEvent( RmVideoEvent.VIDEO_BUFFER_EMPTY, {videoID:videoReportingID, playerID:playerID} );					break;				case "NetStream.Buffer.Full":					if ( videoPlaying ) _videoEvent = new RmVideoEvent( RmVideoEvent.VIDEO_BUFFER_FULL, {videoID:videoReportingID, playerID:playerID} );					break;				case "NetStream.Play.Stop":					//removeProgressListener();					videoComplete();					break;			}			if (_videoEvent) sendVideoEvent (_videoEvent);		}		/**		 * Clears all initial player values once first video is complete or user input.		 */		private function clearInitValues():void		{			initVideoPlayed = true;			isPaused = false;		}		/**		 * On video complete checks for looping or close.		 */		private function handleVideoCompleteProps():void		{			trace( "\n\n\nVIDEO COMPLETE CALLED\n\n\n" );			if( closeOnComplete )    destroy();			if( loopVideoNum != -1 ) loopVideo();		}		private function setListeners():void		{			broadcaster = EventBroadcaster.getInstance();			videoTarget.addEventListener( Event.REMOVED_FROM_STAGE, destroy );			if( ignoreControls ) return;			broadcaster.addEventListener( RmVideoEvent.MUTE_VIDEO, muteAudio );			broadcaster.addEventListener( RmVideoEvent.UNMUTE_VIDEO, unmuteAudio );			broadcaster.addEventListener( RmVideoEvent.PAUSE_VIDEO, pauseVideo );			broadcaster.addEventListener( RmVideoEvent.PLAY_VIDEO, playVideo );			broadcaster.addEventListener( RmVideoEvent.STOP_VIDEO, stopVideo );			broadcaster.addEventListener( RmVideoEvent.SEEK_VIDEO, seekVideo );		}		private function removeListeners():void		{			videoTarget.removeEventListener( Event.REMOVED_FROM_STAGE, destroy );			broadcaster.removeEventListener( RmVideoEvent.MUTE_VIDEO, muteAudio );			broadcaster.removeEventListener( RmVideoEvent.UNMUTE_VIDEO, unmuteAudio );			broadcaster.removeEventListener( RmVideoEvent.PAUSE_VIDEO, pauseVideo );			broadcaster.removeEventListener( RmVideoEvent.PLAY_VIDEO, playVideo );			broadcaster.removeEventListener( RmVideoEvent.STOP_VIDEO, stopVideo );			broadcaster.removeEventListener( RmVideoEvent.SEEK_VIDEO, seekVideo );		}	}}